# -*- coding: utf-8 -*-
"""Analisis Movies.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WXCzSknTjBR8h7gB1y1cMMWM7IWyhwRg

Este Dataset presenta un registro historico de peliculas que estan archivadas en la plataforma IMDb.
IMDb (Internet Movie Database) es una base de datos en línea que proporciona información relacionada con películas, programas de televisión, reparto, equipo de producción, biografías, tráilers, reseñas y calificaciones de usuarios.

Origen: Dataworld
Url: https://data.world/mahe432/movies

Drive Dataset: https://drive.google.com/drive/folders/1BjZGoOKOdeWPTq2KM24M_mEVy6wZ95XL?usp=sharing

## Diccionario de variables

-**imdb_title_id**: ID único de IMDb para identificar cada película.

-**title**: Título de la película.

-**original_title**: Título original de la película.

-**year**: Año de lanzamiento de la película.

-**date_published**: Fecha de publicación de la película.

-**genre**: Género(s) de la película.

-**duration**: Duración de la película en minutos.

-**country**: País(es) de origen de la película.

-**language**: Idioma(s) en los que se habla la película.

-**director**: Director(es) de la película.

-**writer**: Escritor(es) de la película.

-**production_company**: Compañía(s) productora(s) de la película.

-**actors**: Actores principales de la película.

-**description**: Descripción o sinopsis de la película.

-**avg_vote**: Promedio de votos de IMDb para la película.

-**votes**: Número de votos recibidos en IMDb.

-**budget**: Presupuesto de producción de la película.

-**usa_gross_income**: Ingresos brutos en Estados Unidos.

-**worlwide_gross_income**: Ingresos brutos a nivel mundial.

-**metascore**: Puntuación en Metascore (un agregador de reseñas de cine).

-**reviews_from_users**: Número de reseñas de usuarios.

-**reviews_from_critics**: Número de reseñas de críticos.

# LIMPIEZA DE LOS DATOS

Debido a que la columna "budget" tiene monedas de todo el mundo, obtenemos las monedas para luego hacer un diccionario con su cotización a dólar estadounidense.

*Nota*: La cotización es al dólar de hoy, por lo tanto, ciertos presupuestos históricos pueden verse afectados por la fluctuación del dólar con respecto a una moneda en particular.
"""

import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv("IMDb_movies.csv")
df

"""**Nota**: Debido a que la columna 'budget' contiene monedas de todo el mundo, procedemos a hacer su conversion moneda/dolar estadounidense"""

#Obtenemos todos los tipos de monedas de la columna budget

budget_column = df['budget'].str.extract(r'([A-Za-z]+)')

unique_values = budget_column.dropna()[0].unique()

print(unique_values)

#Creamos el diccionario (moneda,conversion a dolar)
tasas_de_cambio = {

    '$': 1,
    'ITL': 0.000842,
    'ROL': 0.2345,
    'SEK': 0.1192,
    'FRF': 0.1092,
    'NOK': 0.1168,
    'GBP': 1.4098,
    'DEM': 0.6272,
    'PTE': 0.1137,
    'CAD': 0.8024,
    'INR': 0.0137,
    'CHF': 1.0995,
    'FIM': 0.1985,
    'JPY': 0.0092,
    'DKK': 0.1534,
    'NLG': 0.5585,
    'PLN': 0.2552,
    'RUR': 0.0135,
    'AUD': 0.7601,
    'KRW': 0.000889,
    'BEF': 0.0312,
    'XAU': 1791.46,
    'HKD': 0.1289,
    'NZD': 0.7225,
    'CNY': 0.1554,
    'ESP': 0.0011,
    'EUR': 1.1192,
    'PYG': 0.00014,
    'ISK': 0.0076,
    'IEP': 1.1827,
    'TRL': 0.1203,
    'HRK': 0.1586,
    'SIT': 0.0041,
    'PHP': 0.0209,
    'DOP': 0.0176,
    'JMD': 0.0067,
    'CZK': 0.0441,
    'SGD': 0.7386,
    'BRL': 0.1926,
    'BDT': 0.0118,
    'ATS': 0.1112,
    'BND': 0.7386,
    'HUF': 0.0033,
    'EGP': 0.0637,
    'THB': 0.0309,
    'GRD': 0.0031,
    'ZAR': 0.0664,
    'NPR': 0.0085,
    'IDR': 0.000069,
    'PKR': 0.0062,
    'EEK': 0.0757,
    'MXN': 0.0499,
    'BGL': 0.6043,
    'YUM': 0.14,
    'MYR': 0.2399,
    'IRR': 0.000024,
    'CLP': 0.0014,
    'SKK': 0.0382,
    'LTL': 0.2932,
    'TWD': 0.0357,
    'MTL': 2.6332,
    'LVL': 1.5258,
    'COP': 0.00027,
    'ARS': 0.0106,
    'UAH': 0.0371,
    'NGN': 0.0024,
    'ILS': 0.3037,
    'VEB': 0.000000000273593,
    'VND': 0.000044,
    'TTD': 0.1477,
    'LKR': 0.005,
    'GEL': 0.3056,
    'RON': 0.2345,
    'MNT': 0.00034,
    'AZM': 0.59,
    'ALL': 0.0097,
    'AMD': 0.0019,
    'AED': 0.2723
}

import numpy as np
def convertir_a_dolares(valor):
    """
    Convierte un valor monetario en una cadena de texto al equivalente en dólares estadounidenses.

    Parámetros:
    valor (str): Una cadena que contiene el tipo de moneda y la cantidad, separadas por un espacio.

    Retorna:
    float: El valor en dólares estadounidenses. Si la moneda no está en el diccionario de tasas de cambio o si el valor es NaN, retorna None.

    Ejemplos:
    >>> convertir_a_dolares('EUR 100')
    110.0

    >>> convertir_a_dolares('JPY 1000')
    9.0

    Nota:
    La cotización es al dólar de hoy, por lo tanto,
     algunos presupuestos históricos pueden verse afectados por la fluctuación del dólar con respecto a una moneda en particular.
    """
    if isinstance(valor, float) and np.isnan(valor):
        return None

    moneda, cantidad = valor.split(' ')
    cantidad = int(cantidad)
    if moneda in tasas_de_cambio:
        tasa = tasas_de_cambio[moneda]
        return cantidad * tasa
    else:
        return None

#creamos una columna budget la cual tiene los valores de la columna original con la funcion aplicada
df_budget = df['budget'].apply(convertir_a_dolares)

#intercambiamos la columna creada por la original
df['budget'] = df_budget

df.info()

#hacemos el mismo proceso para las columnas usa_gross_income y worlwide_gross_income
df_usa_gross_income = df['usa_gross_income'].apply(convertir_a_dolares)
df['usa_gross_income'] = df_usa_gross_income
df_worlwide_gross_income = df['worlwide_gross_income'].apply(convertir_a_dolares)
df['worlwide_gross_income'] = df_worlwide_gross_income

#convertimos las columnas a el formato correcto
df['date_published'] = pd.to_datetime(df['date_published'], format='ISO8601')
#El formato 'ISO8601' se refiere a un estándar internacional para la representación de fechas y horas. Este estándar define
#varios formatos para representar fechas y horas de una manera legible para máquinas y fácilmente interpretable por humanos.
df['usa_gross_income'] = pd.to_numeric(df['usa_gross_income'], errors='coerce').astype(float)
df['worlwide_gross_income'] = pd.to_numeric(df['worlwide_gross_income'], errors='coerce').astype(float)

df.info()

"""# ANALISIS

### Analisis de medidas explorativas
"""

#creamos una matriz de correlacion para orientarnos en nuestro analisis
df_numeric = df.select_dtypes(include=['int', 'float'])
correlation_matrix = df_numeric.corr()
plt.figure(figsize=(10, 8))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f",vmin=-1, vmax=1)
plt.title('Matriz de correlación')
plt.show()

"""### Distribución de presupuesto con outliers"""

plt.figure(figsize=(8, 6))
sns.boxplot(x=df['budget'])
plt.xlabel('Presupuesto')
plt.title('Boxplot de Presupuesto')
plt.show()

"""### Distribución de presupuesto sin outliers"""

# Calcular los rangos intercuartiles
Q1 = df['budget'].quantile(0.25)
Q3 = df['budget'].quantile(0.75)
IQR = Q3 - Q1

limite_inferior = Q1 - 1.5 * IQR
limite_superior = Q3 + 1.5 * IQR

# Filtrar los outliers y crear un nuevo DataFrame sin ellos
df_clean = df[(df['budget'] >= limite_inferior) & (df['budget'] <= limite_superior)]


plt.figure(figsize=(8, 6))
sns.boxplot(x=df_clean['budget'])
plt.xlabel('Presupuesto')
plt.title('Boxplot de Presupuesto sin Outliers')
plt.show()

"""### Media y Mediana de la puntuacion promedio de cada pelicula"""

media_avg_votes = df['avg_vote'].mean()
print("Media de avg_vote:", media_avg_votes)

mediana_avg_votes = df['avg_vote'].median()
print("Media de avg_vote:", mediana_avg_votes)

# Configurar el estilo del gráfico
sns.set(style="whitegrid")

# Crear el histograma de los votos promedio
plt.figure(figsize=(10, 6))
sns.histplot(df['avg_vote'], bins=20, kde=True, color='skyblue', edgecolor='black')

plt.axvline(x=media_avg_votes, color='red', linestyle='--', label='Media')
plt.axvline(x=mediana_avg_votes, color='green', linestyle='--', label='Mediana')
plt.legend()
plt.title('Distribución de los Votos Promedio con Media y Mediana')
plt.xlabel('Votos Promedio')
plt.ylabel('Frecuencia')

plt.show()

"""### Desviacion estandar de la duración de las peliculas"""

desviacion_duracion = df['duration'].std()
print("La desviacion estandar con respecto a la media es: ",desviacion_duracion)

# Calcular la media
media_duracion = df['duration'].mean()

plt.figure(figsize=(10, 6))
plt.hist(df['duration'], bins=20, edgecolor='black', alpha=0.7)

# Agregar líneas verticales para la media y la media +/- una desviación estándar
plt.axvline(media_duracion, color='red', linestyle='--', linewidth=2, label='Media')
plt.axvline(media_duracion + desviacion_duracion, color='orange', linestyle='--', linewidth=2, label='+1 Desviación Estándar')
plt.axvline(media_duracion - desviacion_duracion, color='orange', linestyle='--', linewidth=2, label='-1 Desviación Estándar')

plt.legend()
plt.title('Distribución de la Duración de las Películas con Media y +/- 1 Desviación Estándar')
plt.xlabel('Duración (minutos)')
plt.ylabel('Frecuencia')

# Limitar el eje x
plt.xlim(0, 300) # Por ejemplo, limitar el eje x de 0 a 300 minutos

plt.show()

"""## Analisis comparativo, correlativo y de tendencias

## Pelicula mas taquillera por año
"""

# Obtener el índice de la película con mayores ingresos por año
idx_max_ingresos_por_año = df.groupby('year')['usa_gross_income'].idxmax()

# Filtrar los valores NaN en la serie de índices
idx_max_ingresos_por_año = idx_max_ingresos_por_año.dropna()

# Seleccionar las filas correspondientes a los índices obtenidos
peliculas_max_ingresos_por_año = df.loc[idx_max_ingresos_por_año]

#filtramos las peliculas desde 1960 en adelante para que no haya valores falsos (debido a la conversion a dolar)
peliculas_desde_1960 = peliculas_max_ingresos_por_año[peliculas_max_ingresos_por_año['year'] >= 1960]

#creamos una columna 'hue' para luego utilizarla como parametro en nuestro grafico
peliculas_desde_1960['hue'] = peliculas_desde_1960['title'] + " (" + peliculas_desde_1960['year'].astype(str) + ")"

sns.set_style("whitegrid")

plt.figure(figsize=(12, 6))
sns.barplot(data=peliculas_desde_1960, x='year', y='usa_gross_income', hue= 'hue', dodge=False, palette='viridis')


plt.xlabel('Año')
plt.ylabel('Ingresos Brutos de EE. UU.')
plt.title('Ingresos Brutos de EE. UU. por Año con Películas (desde 1960)')
plt.legend(title='Título de la Película', bbox_to_anchor=(1.05, 1), loc='upper left')
plt.xticks(rotation=75, ha='right',)
plt.grid(axis='y', linestyle='--', alpha=0.7)


plt.tight_layout()
plt.show()

"""## Género mas común"""

# Inicialización de listas y diccionarios
generos_unicos = []
contador_genero = {}

# Iteración sobre la columna 'genre' del DataFrame
for genre in df['genre']:
    # Separación de los géneros usando coma como separador, esto crea una lsita por cada fila
    genero_sep = genre.split(',')
    #iteramos cada lista de genero_sep
    for genero in genero_sep:
        # Eliminación de espacios en blanco antes y después de cada género
        genero = genero.strip()
        # Si el género no está en la lista de géneros únicos, se añade y se inicializa el contador
        if genero not in generos_unicos:
            generos_unicos.append(genero)
            contador_genero[genero] = 1
        else:
            # Si el género ya está en la lista, se incrementa su contador en el diccionario
            contador_genero[genero] += 1

print(generos_unicos)
print(contador_genero)
print(len(generos_unicos))

"""
agrupamos los generos con frecuencia menor a 1500 y los llamamos 'otros', ya que si no el grafico queda con muchos generos
"""
# Inicialización del contador para géneros menos frecuentes
otros = 0

# Copia del diccionario original de conteo de géneros
contador_genero_copia = contador_genero.copy()

# Iteración sobre los géneros y sus frecuencias en la copia del diccionario
for genero, frecuencia in contador_genero_copia.items():
    # Si la frecuencia del género es menor a 1500, se agrupa en 'Otros'
    if frecuencia < 1500:
        otros += frecuencia
        del contador_genero[genero]

# Agrega la suma de los géneros menos frecuentes bajo la categoría 'Otros'
contador_genero['Otros'] = otros

# Impresión del diccionario actualizado de conteo de géneros
print(contador_genero)

sns.set(style="whitegrid")

plt.figure(figsize=(8, 8))
sns.set_palette("colorblind")
plt.pie(contador_genero.values(), labels=contador_genero.keys(), autopct='%1.1f%%', textprops={'fontsize': 10})
plt.title('Distribución de géneros')
plt.axis('equal')
plt.tight_layout()
plt.show()

"""Nota: Se agrupan generos con frecuencia menor a 1500 en la categoria 'otros' para que el grafico sea legible

## Generos mas taquilleros
"""

generos_unicos = []
recaudado_genero = {}

for index, row in df.iterrows():
    # Separación de los géneros usando coma como separador, esto crea una lsita por cada fila
    genero_sep = row['genre'].split(',')
    # Obtención del ingreso mundial de la fila actual
    ingreso_mundial = row['worlwide_gross_income']

    # Iteración sobre cada género de la fila actual
    for genero in genero_sep:
        # Eliminación de espacios en blanco antes y después de cada género
        genero = genero.strip()

        if genero not in generos_unicos:
            # Si el género no está en la lista, se agrega a la lista de géneros únicos
            generos_unicos.append(genero)
            # Inicialización de la recaudación para ese género con el valor de ingreso mundial si está disponible
            if pd.notnull(ingreso_mundial):
                recaudado_genero[genero] = ingreso_mundial
            else:
                recaudado_genero[genero] = 0
        else:
            # Si el género ya está en la lista, se suma el ingreso mundial de la fila actual al total existente
            if pd.notnull(ingreso_mundial):
                recaudado_genero[genero] += ingreso_mundial
            else:
                recaudado_genero[genero] += 0


#Luego procedemos a eliminar los generos donde no se tiene registro de recaudación
recaudado_genero_copia = recaudado_genero.copy()
for genero, recaudacion in recaudado_genero_copia.items():
    if recaudacion <= 0:
        del recaudado_genero[genero]

plt.figure(figsize=(10, 6))
sns.barplot(x=list(recaudado_genero.keys()), y=list(recaudado_genero.values()), order=sorted(recaudado_genero, key=recaudado_genero.get),palette='viridis')
plt.xlabel('Género')
plt.ylabel('Recaudación mundial')
plt.title('Recaudación por género de película')
plt.xticks(rotation=90)
plt.tight_layout()
plt.show()

"""## Directores con mejor puntaje y menor presupuesto promedio"""

directores_unicos = []
directores_mas_5_peliculas = {}

# Iteración sobre cada fila del DataFrame para contar la cantidad de películas dirigidas por cada director
for index, row in df.iterrows():
    director = row['director']
    # Verificar si el director ya está en la lista de directores únicos
    if director not in directores_unicos:
        directores_unicos.append(director)
        # Si no está en la lista, se agrega a la lista de directores únicos y se inicializa su cantidad de películas dirigidas a 1
        directores_mas_5_peliculas[director] = 1
    else:
        # Si ya está en la lista, se incrementa su cantidad de películas dirigidas en 1
        directores_mas_5_peliculas[director] += 1

directores_copia = directores_mas_5_peliculas.copy()

# Iterar sobre los elementos del diccionario para eliminar los directores con 5 o menos películas dirigidas
for director, cantidad_peliculas in directores_copia.items():
    if cantidad_peliculas <= 5:
        # Si la cantidad de películas dirigidas por el director es 5 o menos, se elimina del diccionario
        del directores_mas_5_peliculas[director]

#Calculamos la variable avg_votes_director para obtener el puntaje promedio de cada director
df_directores_mas_5_peliculas = df[df['director'].isin(directores_mas_5_peliculas.keys())]
avg_votes_director = df_directores_mas_5_peliculas.groupby('director')['avg_vote'].mean()

# Calcula el presupuesto promedio por director para aquellos con más de 5 películas dirigidas
presupuesto_promedio_por_director = df_directores_mas_5_peliculas.groupby('director')['budget'].mean()


# Crea un DataFrame con los promedios calculados de avg_vote y presupuesto promedio
df_promedios = pd.DataFrame({'avg_vote_promedio': avg_votes_director,  'presupuesto_promedio ($)': presupuesto_promedio_por_director})

# Dropeamos los presupuestos que son 0 o Nan ya que consideramos que no son reales
df_promedios = df_promedios.dropna(subset=['presupuesto_promedio ($)'])
df_promedios = df_promedios[df_promedios['presupuesto_promedio ($)'] > 0]

# Ordena los directores por su presupuesto promedio en orden ascendente y su promedio de avg_vote en orden descendente,
# luego selecciona los 10 primeros directores de esta lista ordenada
top_10_directores = df_promedios.sort_values(by=['presupuesto_promedio ($)', 'avg_vote_promedio'], ascending=[True, False]).head(10)

fig, ax1 = plt.subplots(figsize=(14, 8), nrows=1, ncols=2)

# Crear el gráfico de barras horizontal para 'avg_vote_promedio'
sns.barplot(x='avg_vote_promedio', y=top_10_directores.index, data=top_10_directores, palette='viridis', orient='h', ax=ax1[0])
ax1[0].set_xlabel('Promedio de avg_vote')
ax1[0].set_ylabel('Director')
ax1[0].set_title('Promedio de avg_vote')

#ax1[0] y ax1[1] son los ejes del primer y segundo subgráfico

# Crear el gráfico de barras horizontal para 'presupuesto_promedio ($)'
sns.barplot(x='presupuesto_promedio ($)', y=top_10_directores.index, data=top_10_directores, palette='viridis', orient='h', ax=ax1[1])
ax1[1].set_xlabel('Presupuesto promedio ($)')
ax1[1].set_ylabel('')
ax1[1].set_title('Presupuesto Promedio ($)')

plt.tight_layout()
plt.show()

"""## Top 10 películas mejor valuadas ( Con votos mayores a 500.000)"""

#filtramos las filas que tienen mas de 500.000 votos y ordenamos por avg_vote
df_filtered = df[df['votes'] > 50000]
df_sorted = df_filtered.sort_values(by='avg_vote', ascending=False)

top_10_movies = df_sorted.head(10)
sns.set(style="whitegrid")
plt.figure(figsize=(10, 6))
ax = sns.barplot(x='avg_vote', y='title', data=top_10_movies, palette='viridis')
ax.set_xlabel('Calificación Promedio')
ax.set_ylabel('Título de la Película')
ax.set_title('Top 10 Mejores Películas con más de 50000 votos')
plt.show()

"""Nota: La eleccion de peliculas que tengan mas de 500.000 votos se debe a que existen peliculas con 1 solo voto con la maxima calificacion, esta medicion es mas real y general

## Cantidad de películas por año de lanzamiento hasta 2017
"""

# Filtrar los datos hasta 2020
peliculas_por_año = df[df['year'] <= 2017]

# Calcular la cantidad de películas por año
peliculas_por_año = peliculas_por_año.groupby('year').size().reset_index(name='cantidad')

# Ahora, puedes crear el connected scatter plot utilizando Seaborn
sns.set(style="whitegrid")  # Establecer el estilo del gráfico

# Crear el connected scatter plot
plt.figure(figsize=(10, 6))  # Tamaño del gráfico
sns.lineplot(data = peliculas_por_año, x= 'year', y='cantidad', marker='o', linestyle='-')

# Añadir título y etiquetas de los ejes
plt.title('Cantidad de películas por año de lanzamiento hasta 2017')
plt.xlabel('Año de lanzamiento')
plt.ylabel('Cantidad de películas')

# Mostrar el gráfico
plt.show()

"""Observación: Podemos ver que la cantidad de peliculas crece exponencialmente

## Directores con mejores puntajes
"""

# Calcular el número de películas por director
movies_per_director = df['director'].value_counts().reset_index()
movies_per_director.columns = ['director', 'movie_count']

# Filtrar los directores con al menos 5 películas
directors_with_enough_movies = movies_per_director[movies_per_director['movie_count'] >= 5]

# Unir con el DataFrame original para filtrar las filas correspondientes
df_filtered_directors = df[df['director'].isin(directors_with_enough_movies['director'])]

# Agrupar por director y calcular el puntaje promedio
average_score_by_director = df_filtered_directors.groupby('director')['avg_vote'].mean().reset_index()

# Ordenar por puntaje promedio en orden descendente
sorted_by_score = average_score_by_director.sort_values(by='avg_vote', ascending=False)

# Seleccionar los primeros 20 directores con mejores puntajes
top_20_directors = sorted_by_score.head(20)

# Graficar usando Seaborn
plt.figure(figsize=(14, 8))
sns.barplot(x='avg_vote', y='director', data=top_20_directors, palette='viridis')
plt.title('Top 20 Directores con Mejores Puntajes Promedio (Mínimo 5 Películas)')
plt.xlabel('Puntaje Promedio')
plt.ylabel('Director')
plt.show()

"""Observación: Podemos ver que los primeros directores son de origen hindú, esto se podria explicar porque la India tiene una larga historia de cine, con una industria cinematográfica muy desarrollada, a su vez la india representa un 16.67% de la población mundial, tiene sentido que al tener una gran industria cinematografica nacional, los directores mas votados y mejores calificados sean de ahí

## Productoras con mejores puntajes
"""

# Calcular el número de películas por director
movies_per_company = df['production_company'].value_counts().reset_index()
movies_per_company.columns = ['production_company', 'movie_count']

# Filtrar los directores con al menos 5 películas
companies_with_enough_movies = movies_per_company[movies_per_director['movie_count'] >= 10]

# Unir con el DataFrame original para filtrar las filas correspondientes
df_filtered_companies = df[df['production_company'].isin(companies_with_enough_movies['production_company'])]

# Agrupar por director y calcular el puntaje promedio
average_score_by_company = df_filtered_companies.groupby('production_company')['avg_vote'].mean().reset_index()

# Ordenar por puntaje promedio en orden descendente
sorted_by_score = average_score_by_company.sort_values(by='avg_vote', ascending=False)

# Seleccionar los primeros 20 directores con mejores puntajes
top_20_companies = sorted_by_score.head(20)

# Graficar usando Seaborn
plt.figure(figsize=(14, 8))
sns.barplot(x='avg_vote', y='production_company', data=top_20_companies, palette='viridis')
plt.title('Top 20 Productoras con Mejores Puntajes Promedio (Mínimo 5 Películas)')
plt.xlabel('Puntaje Promedio')
plt.ylabel('Productora')
plt.show()

"""## Relacion entre presupuesto y puntaje

"""

media_avg_vote = df['avg_vote'].mean()
media_budget = df['budget'].mean()

sns.set(style="dark") # Establecer el estilo del gráfico

# Limitar el rango del eje x presupuesto a 350 millones de dólares
plt.ylim(0, 350000000)

sns.scatterplot(x='avg_vote', y="budget", data=df)

plt.title('Relación entre Presupuesto y puntaje de Películas')
plt.xlabel('Puntaje')
plt.ylabel('Presupuesto ($)')
plt.axvline(x=media_avg_vote, color='red', linestyle='--', label='Media de avg_vote')
plt.axhline(y=media_budget, color='red', linestyle='--', label='Media de budget')
plt.legend() # Mostrar la leyenda

# Mostrar el gráfico
plt.show()

"""Podemos observar una distribucion cuasi gaussiana siemtrica hacia la derecha o una distribución asimétrica positiva. Lo que indica que las peliculas con mayor presupuesto son levemente mas exitosas"""

correlation = df['avg_vote'].corr(df['budget'])
print("Coeficiente de correlación:", correlation)

"""Podemos observar que el coeficiente de correlacion es debil, pero aun así podemos ver que tiende levemente hacia la derecha

## Top 10 productoras que mas dinero invirtieron vs Top 10 productoras que mas dinero recaudaron
"""

# Calcular el presupuesto total y los ingresos mundiales por productora
presupuesto_por_productora = df.groupby('production_company')['budget'].sum()
ingresos_mundiales_por_productora = df.groupby('production_company')['worlwide_gross_income'].sum()

# Seleccionar las 10 principales productoras por presupuesto y por ingresos mundiales
top_10_presupuesto = presupuesto_por_productora.nlargest(10)
top_10_ingresos_mundiales = ingresos_mundiales_por_productora.nlargest(10)

plt.figure(figsize=(14, 6))

# Subgráfico para las 10 principales productoras por presupuesto
plt.subplot(1, 2, 1)
sns.barplot(x=top_10_presupuesto.index, y=top_10_presupuesto.values, palette='Blues_d')
plt.title('Top 10 Productoras por Presupuesto')
plt.xlabel('Productora')
plt.ylabel('Presupuesto Total ($)')
plt.xticks(rotation=45, ha='right')

# Subgráfico para las 10 principales productoras por ingresos mundiales
plt.subplot(1, 2, 2)
sns.barplot(x=top_10_ingresos_mundiales.index, y=top_10_ingresos_mundiales.values, palette='Reds_d')
plt.title('Top 10 Productoras por Ingresos Mundiales')
plt.xlabel('Productora')
plt.ylabel('Ingresos Mundiales Totales ($)')
plt.xticks(rotation=45, ha='right')

plt.tight_layout()
plt.show()